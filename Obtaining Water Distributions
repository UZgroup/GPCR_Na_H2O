#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct  2 11:03:31 2019
@author: neilthomson
"""
#https://www.mdanalysis.org/

import MDAnalysis
import MDAnalysis.analysis.hbonds
from collections import OrderedDict
import matplotlib.pyplot as plt
import numpy as np
import math
import re
from tqdm import tqdm

##frame rate for the water angles should be adjusted according to t=0.249ns - the
##fastest auto-correlation time for waters in reference below
##https://reader.elsevier.com/reader/sd/pii/S0006349516306580?token=A321CBF83921B527B557865955ACA1D2C859AA2F94D3622497167DEB71D43165CCBD843D2175F07757B6A8F9EE2F2EDF

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""       
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
'FUNCTION'

'OBTAINING THE DIPOLE ANGLES FOR EACH BINDING SITE'
def get_dipole(water_atom_positions):
    
    ##obtaining the coordinates for each of the individual atoms
    Ot0 = water_atom_positions[::3]
    H1t0 = water_atom_positions[1::3]
    H2t0 = water_atom_positions[2::3]
#    print(Ot0,H1t0,H2t0)
    ##finding the dipole vector
    dipVector0 = (H1t0 + H2t0) * 0.5 - Ot0
    
    ##getting the dot product of the dipole vector about each axis
    unitdipVector0 = dipVector0 / \
        np.linalg.norm(dipVector0, axis=1)[:, None]
#    print(unitdipVector0)
    x_axis=unitdipVector0[0][0]
    y_axis=unitdipVector0[0][1]
    z_axis=unitdipVector0[0][2]
    
    ##converting the cosine of the dipole about each axis into phi and psi spherical coordinates
    psi=math.degrees(np.arctan2(y_axis,x_axis))
    phi=math.degrees(np.arccos(z_axis/(np.sqrt(x_axis**2+y_axis**2+z_axis**2))))   

    if psi < 0:
        psi+=360
    if phi < 0:
        phi+=360
    
    return(psi,phi)
    
    
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""      
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""      
        
##looping over all the simulations and waters to obtain
##water angles for all 5 waters in each simulation

##run1=water number
##run2=simulation number
for run1 in range(5):
    for run2 in range(3):   
         
        ##obtaining the 'universe', i.e. the complete tractory and topology information of the simulation
        if run2==0:
            u = MDAnalysis.Universe('../../4dkl/na4dkl/protein_sol.gro', '../../4dkl/na4dkl/allsol.xtc')
        if run2==1:
            u = MDAnalysis.Universe('../../4dkl/nona4dkl/protein_sol.gro', '../../4dkl/nona4dkl/allsol.xtc')
        if run2==2:
            u = MDAnalysis.Universe('../../4dkl/prot4dkl/protein_sol.gro', '../../4dkl/prot4dkl/allsol.xtc')

        philist=[]
        psilist=[]
        
        counting=[]
        
        ###extracting (psi,phi) coordinates for each water dipole specific to the frame they are bound
        #print('extracting (psi,phi) coordinates for each water dipole specific to the frame they are bound')
        for i in tqdm(range(len(u.trajectory))):       
            
            u.trajectory[i]
            
            ##specifying the tetrahedrons and triangles whose centre of geometry forms the origin of 
            ##the sphere for which each water pocket is defined by
            
            ##labelling uses a residue that is proximal to the water site
            
            ##n1.50 ==wat1
            if run1==0:
                waters_resid=u.select_atoms("resname SOL and sphzone 4 (name CA and (resid 86 or resid 110 or resid 114 or resid 332))").resids
            ##n7.49 ==wat2
            if run1==1:
                waters_resid=u.select_atoms("resname SOL and sphzone 4 (name CA and (resid 287 or resid 328 or resid 332))").resids
            ##c6.47 ==wat3
            if run1==2:
                waters_resid=u.select_atoms("resname SOL and sphzone 4 (name CA and (resid 292 or resid 295 or resid 321))").resids
            ##d3.49 ==wat4
            if run1==3:
                waters_resid=u.select_atoms("resname SOL and sphzone 5 (name CA and (resid 163 or resid 179 or resid 184))").resids
            ##w4.50 ==wat5
            if run1==4:
                waters_resid=u.select_atoms("resname SOL and sphzone 5 (name CA and (resid 109 or resid 157 or resid 187 or resid 191))").resids
                                                
            ##making a list of water residue IDs for every frame where all three atoms of the water appear in the pocket
            multi_waters_id=[]
            for elem in list(set(waters_resid)):
                if list(waters_resid).count(elem)==3:
                    multi_waters_id.append(elem)
            counting.append(multi_waters_id)
        
        ##making a list of the water IDs that appear in the simulation in that pocket (no duplicates)
        flat_list = [item for sublist in counting for item in sublist]
        no_dups=list(set(flat_list))
        
        ###extracting (psi,phi) coordinates for each water dipole specific to the frame they are bound
        #print('extracting (psi,phi) coordinates for each water dipole specific to the frame they are bound')
        for i in tqdm(range(len(u.trajectory))):       
            u.trajectory[i]
            waters_resid=counting[i]
            ##extracting the water coordinates based on the water that appears in that frame
            ##if there is only one water in the pocket then...
            if len(waters_resid)==1:        
                ##(x,y,z) positions for the water atom (residue) at frame i
                water_indices=u.select_atoms('resid ' + str(waters_resid[0])).indices
                water_atom_positions=u.trajectory[i].positions[water_indices]
                #print(water_atom_positions)
                psi, phi = get_dipole(water_atom_positions)
                psilist.append(psi)
                philist.append(phi)
                
            ##if there are multiple waters in the pocket then find the 
            ##water that appears in the pocket with the largest frequency and use that 
            ##ID number to get the coordinate for that frame
            elif len(waters_resid)>1:
                
                freq_count=[]
                for ID in waters_resid:
                    freq_count.append([flat_list.count(ID),ID])
                freq_count.sort(key = lambda x: x[0])
                
                ##(x,y,z) positions for the water atom (residue) at frame i
                water_indices=u.select_atoms('resid ' + str(freq_count[-1][1])).indices
                water_atom_positions=u.trajectory[i].positions[water_indices]
                #print(water_atom_positions)
                psi, phi = get_dipole(water_atom_positions)
                psilist.append(psi)
                philist.append(phi)
        
        
            ##if there are no waters bound then append these coordinates to identify 
            ##a separate state
            elif len(waters_resid)<1:
                psilist.append(10000.0)
                philist.append(10000.0)
        
#        plt.figure()
#        plt.plot(np.histogram([elem for elem in philist if elem !=10000.0],bins=60)[1][0:-1],np.histogram([elem for elem in philist if elem !=10000.0],bins=60)[0],label='D2.50 + Na')
#        plt.xlabel('$\phi$')
#        plt.figure()
#        plt.plot(np.histogram([elem for elem in psilist if elem !=10000.0],bins=60)[1][0:-1],np.histogram([elem for elem in psilist if elem !=10000.0],bins=60)[0],label='D2.50 + Na')
#        plt.xlabel('$\psi$')
                
                
        ##exporting the data
        names1=['na','nona','prot']
        names2=['n150','n749','c647','d349','w450']
        
        
        filepsi='waterallchis/'+str(names1[run2])+'4dkl_'+str(names2[run1])+'_water_distspsi.txt'
        filephi='waterallchis/'+str(names1[run2])+'4dkl_'+str(names2[run1])+'_water_distsphi.txt'
        
        np.savetxt(filepsi,np.array(psilist))
        np.savetxt(filephi,np.array(philist))
